/////////////////////////////////////////////////////////////
// strings.cpp
//
// This file was generated by CXR, the literal string encryptor.
// CXR, Copyright 2002, Smaller Animals Software, Inc., all rights reserved.
//
// Please do not edit this file. Any changes here will be overwritten on the next compile.
// If you wish to make changes to a string, please edit:
//     D:\Progs\CXR\Test\strings.cxr
//

/////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "cxr_inc.h"

////////////////////
// a little comment
										 
											   
///////////////////////////
#ifdef _USING_CXR
const char* pString1 = "\x82\x8d\x87\x8d\x85\x84\x88\x8f\x8a\x8d\x88\x8c\x84\x83\x81\x82\x8a\x80\x8b\x84\x8c\x86\x8b\x8b\x80\x88\x8f\x8c\x8f\x8f\x8c\x85\x81\x8d\x81\x87\x8d\x8d\x8d\x8a\x8e\x80\x89\x8e\x8a\x83";  // this is fun
#else
const char* pString1 = _CXR("AbcdEfg1234  blah\tblah");  // this is fun
#endif


// you can put comments anywhere 			 	 		 		 	  				 					   
  
///////////////////////////
#ifdef _USING_CXR
const char* pString2 = "\x8c\x82\x8a\x81\x8f\x8a\x84\x89\x83\x86\x84\x82\x80\x8d\x8b\x81\x89\x86\x85\x88\x81\x84\x8e\x84\x87\x81\x84\x89\x85\x8d\x86\x8c\x80\x82\x86\x8d\x88\x8f\x82\x88\x8b\x86\x8f\x85\x82\x8e\x88\x8b\x85\x88\x84\x8e\x86\x88\x86\x84\x85\x8a\x89\x8b\x8e\x81\x8c\x8d\x84\x84\x8e\x81\x84\x89\x87\x87\x8e\x80\x82\x80\x8a\x88\x88\x8f\x85\x8a\x88\x8b\x81\x8e\x81\x8b\x80\x81\x8e\x83\x82\x89\x81\x8c\x86\x83\x87\x84\x8c\x8d\x86\x85\x81\x8a\x8c\x87\x8d\x83\x83\x86\x88\x8b\x84\x89\x8c\x8a\x84\x84\x8a\x8a\x8e\x81\x8c\x83\x88\x8b\x84\x8e\x85\x86\x83\x86\x82\x82\x82\x86\x81\x88\x8a\x8b\x8d\x86\x8c\x87\x8d\x8d\x8c\x81\x86\x83\x89\x86\x83\x8f\x85\x88\x89\x82\x85\x87\x80\x87\x86\x87";
#else
const char* pString2 = _CXR("This is a long one, not that it should matter...blab blah blah blah. i love trash.");
#endif


// you can even put normal C++ code in this file
class fred
{
public:
	fred() {}
	~fred() {}																			 

private:							   
	int m_iFredsStuff;
};
// ... tho i don't know why you would want to	   			  	 				  


/////////////////////////////////////////////////////////////
// CXR-generated decoder follows

#include <algorithm>
const char * __pCXRPassword = "SexyBeast";
const int __iCXRDecBase1 = 128;
const int __iCXRDecBase2 = 128;

class CCXR
{
protected:
   CCXR(const BYTE *key, unsigned int ks)
   {
      int i;BYTE rs;unsigned kp;
      for(i=0;i<256;i++)c[i]=i;kp=0;rs=0;for(i=255;i;i--)std::swap(c[i],c[kr(i,key,ks,&rs,&kp)]);r2=c[1];r1=c[3];av=c[5];lp=c[7];lc=c[rs];rs=0;kp=0;
   }
	inline void SC(){BYTE st=c[lc];r1+=c[r2++];c[lc]=c[r1];c[r1]=c[lp];c[lp]=c[r2];c[r2]=st;av+=c[st];}
	BYTE c[256],r2,r1,av,lp,lc;    

   BYTE kr(unsigned int lm, const BYTE *uk, BYTE ks, BYTE *rs, unsigned *kp)
   {
      unsigned rl=0,mk=1,u;while(mk<lm)mk=(mk<<1)+1;do{*rs=c[*rs]+uk[(*kp)++];if(*kp>=ks){*kp=0;*rs+=ks;}u=mk&*rs;if(++rl>11)u%=lm;}while(u>lm);return u;
   }
};
struct CXRD:CCXR
{
	CXRD(const BYTE *userKey, unsigned int keyLength=16) : CCXR(userKey, keyLength) {}
	inline BYTE pb(BYTE b){SC();lp=b^c[(c[r1]+c[r2])&0xFF]^c[c[(c[lp]+c[lc]+c[av])&0xFF]];lc=b;return lp;}
};
CString __CXRDecrypt(const char *pIn)
{
   CString x;char b[3];b[2]=0;
   CXRD sap((const BYTE*)__pCXRPassword, strlen(__pCXRPassword));
   int iLen = strlen(pIn);
   if (iLen > 2)
   {
      int ibl=strlen(pIn);
      if (ibl&0x01)
      {
         ASSERT(!"Illegal string length in Decrypt");
         return pIn;
      }
      ibl/=2;
      for (int i=0;i<ibl;i++)
      {
         int b1 =pIn[i*2]-__iCXRDecBase1;int b2=pIn[i*2+1]-__iCXRDecBase2;
         int c = (b1 << 4) | b2; char ch =(char)(sap.pb((BYTE)(c)));
         if (i>0) x+=ch;
      }
   }
   return x;
}
